* Python Coding Convention

본 Coding Convention 은 PET 8(Python Enhance Proposal)에서 제안 하는 내용을 기본으로 따릅니다.

1. 규칙 예외 사항 
  -- 스타일 가이드의 일관선은 중요하지만 그보다 더 중요한 것은 프로젝트 전체의 일관성은 더욱 중요하며, 하나의 모듈이나 함수의 일관성은 더더욱 중요하다.      
  -- 다음과 같은 두 가지의 사항에 있어서 규칙을 지키지 않는 것을 심각하게 고려하여 판단 한다.
    == 규칙을 적용한 코드가 (규칙을 숙지한 사람들 눈에도) 읽기 어려운 경우      
    == 일관성을 지키려고 한 수정이 다른 규칙을 어기는 경우
    
2. 사용 Python Version  
  -- Python 3.5.2
  
3. Source File Encoding   
  -- Python3 은 항상 UTF-8 방식을 사용한다.    
  -- Python3 은 따라서 별도의 인코딩 방식의 정의가 필요하지 않다.   
  -- Python3 이상의 버전에서는 ASCII 로만 이루어진 식별자를 사용해야 하며, 반드시 영어 단어를 사용하도록 권장한다. 
  
4. Code Lay-Out
  -- 들여쓰기(Indentation)
    == 들여쓰기는 공백(Space) 4칸을 권장(Python3은 space, tap 혼용을 금한다.)      
    == 연속되는 문장은 괄호(소, 중, 대)를 이용하여 수직 정렬하거나 'hanging indent'를 사용한다.      
    == 다양한 hanging indent 예시    
    == if문 예시    
    == 여러 줄의 생성자의 닫히는 괄호(소, 중, 대)는 마지막 줄의 공백이 아닌 첫번째 문자(요소) 위치에 오거나 마지막 줄에서 생성자가 시작되는 첫번째 열에 위치한다.
    
  -- 한줄 최대 길이(Maximun Line Length)
    == 모든 코드는 한 줄에 최대 79자 까지 쓰는 것을 허용한다.      
    == Docstring 또는 주석은 72자 까지 쓰도록 한다.    
    == 여러 줄로 길게 표현되는 문장은 괄호(소, 중, 대)를 이용해 여러 행으로 분리해 표현    
    == 어떤 경우에는 백슬래시(backslash)를 사용해 연속되는 문장의 줄바뀜을 표현하는 것이 적절하다.     
    == with문 예시
    
  -- 이항연산자 줄바뀜
    == 이항연산자의 줄바뀜 위치로 연산자의 앞, 뒤 모두를 허용한다.     
    == 하지만 가독성을 고려해 연산자의 앞에서 줄바꿈 하는 것을 권장한다.(최신 표현법)
  
  -- 빈줄(Blank Lines)        
    == 최상위(Top-Level) 함수와 클래스 정의는 2줄씩 띄어 쓰기    
    == 클래스 내의 메소드 정의는 1줄씩 띄어 쓰기
  
  -- 임포트(Import)
    == Import는 반드시 행을 분리해서 선언한다.    
    == 다음의 경우는 예외로서 허용된다.    
    == Import는 파일 상단의 파일 주석과 Docstring 바로 아래, 그리고 전역변수, 상수 선언부 위에 위치한다.     
    == Import는 아래의 순서로 그룹지어 선언한다.      
      --> standard library imports     
      --> related third party imports  
      --> local application/libarary specific imports 
    == Import 그룹 각각은 빈 줄 하나로 구분한다.  
    == Improt는 절대경로를 이용한 방법을 권장한다. (가독성을 높여주고 동작도 더 잘 되도록 한다.)   
    == 와일드카드 Import는 절대 사용하지 않는다. 
 
  -- 모듈 레벨의 dunder names        
    == 모듈 레벨의 dunder(앞 뒤로 밑줄 2개씩 있는 것)은 Docstring 뒤에 그리고 Import 선언 앞에 와야 한다.    
    == from __future__ import는 Docstring 바로 뒤에 그 어떤 코드보다 먼저 위치해야 한다. 그 뒤에 dunder가 위치
    
5. 따옴표(String Quotes)
  -- Python에서 문자열을 표현할때 큰 따옴표, 작은 따옴표 아무거나 사용이 가능하다.   
  -- 가독성을 고려해 이스케이프 문자 사용을 피하도록 적절히 따옴표를 선택해 사용.  
  -- 세 개의 따옴표를 사용할 때에는 반드시 큰 따옴표를 사용
  
6. 표현식 내에서 공란 처리(Whitespace in Expressions and Statements)   
  -- 아래와 같은 상황에서 무의미한 공백을 피하자.
    == 괄호(소, 중, 대) 안의 양쪽 끝   
    == 콤마, 세미콜론, 콜론 바로 앞
    == 슬라이스에서 콜론은 우선 순위가 낮은 이항연산자와 유사항 방식으로 사용되며 양쪽에 동일한 공간을 할당해야 한다. 
    == 확장된 슬라이스에서 모든 콜론은 같은 크기의 공간이 할당되어야 한다.  
    == 피연산자가 누락되었을 경우 공백을 주지 않는다.
    == 함수 호출 시 뒤 인자를 넣기 위한 소괄호의 바로 앞
    == 리스트나 사전의 인덱스나 슬라이스에 사용되는 대괄호의 바로 앞
    == 대입 연산자의 앞뒤는 공백을 주어야 함
    == 기타 유의사항
      --> 문장의 마지막에 따라오는 공백을 없게 하자.(잘 안보이기 때문에 혼란이 발생할 수 있다.)     
      --> 모든 이항연산자(대입, 증감, 비교, 부울(Boolean)) 앞뒤로는 공백을 두어야 한다.
      --> 우선순위가 다른 연산자를 동시에 사용할 경우 낮은 순위의 연산자에 공백을 주여야 한다.      
      --> 절대 한 칸을 초과하는 공백을 사용해서는 안되며, 이항연산자의 양쪽은 같은 공백을 갖도록 해야 한다.
      --> 키워드 인자나 디폴트 인자에 사용되는 대입연산자는 절대로 공백을 사용하지 않는다.
      --> Function annotation에 사용되는 콜론은 기존의 룰을 따르며, '->'는 양 옆에 공백을 한 칸씩 가진다.
      --> argument annotation을 디폴트 변수에 사용할 때, 기존의 디폴트 변수에 사용할 때의 공백 없는 대입연산자와는 다르게 대입연산자 앞 뒤에 공백을 한 칸씩 가진다.
      --> 여러 구문이 한 줄에 오는 것은 보통 권장하지 않는다.
      --> 예외적으로 짧은 길이의 if, for, while 구문에서 여러 구문을 한 줄에 써도 되지만, 절대로 여러 줄의 절에서는 한 줄에 쓰면 안된다.               --> 긴 줄에서의 폴딩을 피해라

7. 주석(Comments)
  * 주석은 코드가 업데이트 될 때마다 반드시 같이 업데이트 해야 한다.  
  * 주석은 반드시 완전한 문장형태여야 한다. 만약 주석이 구문이거나 한 문장일 경우, 첫 글자는 대문자를 쓴다.(첫 단어가 소문자 식별자 인 경우 그대로 소문자를 사용)  
  * 주석이 짧을 경우 마침표가 생략될 수 있다.   
  * 블록 주석의 경우 주로 완전한 문장을 사용하며 문장의 마지막은 마침표로 끝난다.   * 마침표 뒤에는 두 칸의 공백을 준다.   
  * 주석은 가능한 영어로 쓰도록 권장.
  
  -- 블록 주석(Block Comments)
    == 블록 주석은 뒤에 따라오는 코드에 대한 설명이며 뒤에 따라오는 코드와 들여쓰기 수준을 맞춘다    
    == 모든 줄은 # 뒤에 한 칸 공백을 주고 작성한다.(주석 안 들여쓰기된 텍스트가 있을 땐 제외)
    == 블록 주석의 문단은 # 기호 한줄로 구분한다.
    
  -- 인라인 주석(Inline Comments)
    == 인라인 주석은 잘 사용되지 않는다.    
    == 인라인 주석은 한 구문과 같은 줄에 쓰는 주석을 뜻한다. 인라인 주석은 구문과 적어도 2칸 이상의 공백으로 구분(4칸 권장)   
    == 인라인 주석은 # 기호와 한 칸 공백을 주고 작성을 시작한다.
    
  -- Documentation String
    == public 모듈, 함수, 클래스, 메소드에 대해서 Docstrings을 작성해야 한다.    
    == non-public 함수에 대해서는 Docstring이 필요 없음.  
    == Docstrings는 def 문 바로 아랫줄에 위치    
    == Docstrings 마지막 줄은 """ 기호 한줄로 끝내야 한다.   
    == 한 줄짜리 Docstrings는 같은 줄 마지막에 """ 기호를 사용해 끝내도록 한다.

8. Naming Conventions

  -- Overriding Principle 
    == public API로 구현되는 클래스, 함수, 모듈은 그 구현내용보다는 사용법을 나타내도록 명명하는 것을 권장한다.

  -- Naming Styles 설명

    == b(소문자 하나)
    == B(대문자 하나)
    == lowercase
    == lower_case_with_underscore
    == UPPERCASE
    == UPPER_CASE_WITH_UNDERSCORE
    == CapitalizedWords(or CapWords or CamelCase) - 약어를 사용할 경우 전부 대문자를 사용한다.
    == mixedCase(CapWords와 다름, 첫 글자가 소문자)
    == Capital_Words_With_Underscores

    == 다음의 특별한 경우에서는 이름의 앞, 뒤에 언더스코어를 사용한다.

      --> _single_leading_underscore: 드물게 내부에서 사용하는 지시자 (ex) from M import * 에서 언더스코어를 사용한 객체는 임포트 하지 않는다.
      --> single_trailing_underscore_: 파이썬 키워드와 충돌을 막기 위해

      --> __double_leading_underscore: 클래스 attribute를 명명할때 사용, 변수를 mangling하게 한다. (FooBar 클래스 안의 __boo는 _FooBar__boo가 된다)
      --> __double_leading_and_trailing_underscore__: 'magic 객체', 사용불가, 미리 정의되어 있는 이름만 사용 가능하다.


  -- Package and Module Names

    == 모듈이름은 짦아야 하고 모두 소문자를 사용하며, 가독성을 위해 언더스코어를 사용한다. 
    == 패키지의 이름도 짧아야 하고 모두 소문자를 사용하지만 언더스코어는 사용하지 않는다.
    == 모듈 이름은 Python 파일(.py)에 대응하기 때문에 파일 시스템의 영향을 받으므로 항상 주의해야 한다.
    == C++ 확장 모듈은 밑줄로 시작해야 한다.

  -- Class Names

    == 클래스 이름은 CapWords 방식을 따른다.
    == 내부적으로 쓰이면 밑줄을 앞에 붙인다.
    == 예외(Exception)는 실제로 에러인 경우 "Error"를 뒤에 붙여야 한다.

  -- Function Names

    == 함수명은 소문자로 구성하며 필요하면 언더스코어를 이용해서 나눈다.
    == 대소문자 혼용(mixedCase)은 이미 흔하게 사용되는 부분에 대해서만 하위호환을 위해 허용한다.

  -- Function and Method arguments

    == 인스턴스 메소드의 첫 인수로 반드시 'self'를 쓴다.
    == 클래스 메소드의 첫 인수로는 반드시 'cls'를 쓴다.
    == 인수명이 키워드와 충돌될 경우, 인수명을 축약하거나 인수명을 조금 변경하는 것 보다, 인수명 뒤에 언더스코어를 붙여 사용한다. 
    == 제일 좋은 방법은 충돌이 없게끔 동의어를 활용해 이름을 짓는 것이다. 

  -- Method Names and Instance Variable

    == 함수명명 규칙을 따른다. (언더스코어를 사용한 소문자 표기)
    == non-public 메소드, 인스턴스 변수에는 언더스코어 하나를 앞에 붙인다.
    == 서브클래스와의 충돌을 피하기 위해 앞에 언더스코어를 2개 붙여 Python 이름 mangling 규칙을 따르도록 한다.
 
  -- 상수(Constants)
  
    == 상수는 주로 모듈레벨에서 정의되며 언더스코어를 이용한 대문자 표기법을 사용한다. 
    == ex) MAX_OVERFLOW, TOTAL 과 같은 방식으로 표기한다.

9. Programming Recommendations

  -- 코드는 될 수 있으면 어떤 구현(PyPy, Jython, IronPython 등)에서도 불이익을 없게끔 작성되어야 한다.

  -- 'None'을 비교할 때는 'is'나 'is not'만 사용한다.

  -- 클래스 기반의 예외를 사용하도록 한다.
  
    == 모듈이나 패키지에 자기 도메인에 특화된(domain-specific) 예외 클래스(base exception class)를 정의해서 사용하도록 한다.
    == 예외 클래서 정의시 반드시 Docstring(문서화 문자열)을 포함해야 한다.

  -- 예외를 'exception:'로 정의해서 사용하는 것보다는 명확하게 예외를 명시하도록 한다. 'exception ImportError:'

  -- 'try:' 블록의 코드는 필요한 것만 최소한으로 작성한다.

  -- 'string' 모듈보다는 'string' 메소드를 사용한다. 메소드는 모듈보다 더 빠르고, 유니코드 문자열에 대해 같은 API를 공유한다. 

  -- 접두사나 접미사를 검사할때는 'startswith()'와 'endwith()'를 사용한다.

  -- 객체의 타입을 비교할 때는 'isinstance()'를 사용한다.

  -- 빈 시쿼스(문자열, 리스트(list), 튜플(tuple))는 조건문에서 거짓(false)으로 처리된다. 

  -- 블린형(boolean)의 값을 조건문에서 '=='를 통해서 비교해서는 안된다.



참고
http://yoonpunk.tistory.com/1
https://spoqa.github.io/2012/08/03/about-python-coding-convention.html
